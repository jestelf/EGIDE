<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Платформа EGIDE — карта сервисов</title>
<style>
  :root { color-scheme: dark; }
  html,body { height:100%; }
  body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#0b0d10; color:#e7edf5; display:grid; grid-template-rows:auto 1fr auto; overflow:hidden; }

  /* top bar */
  #topbar { display:flex; align-items:center; gap:12px; padding:10px 14px; border-bottom:1px solid #1c2430; background:#0f141b; }
  .btn { border:1px solid #273446; background:#182333; color:#dfe7f1; padding:6px 10px; border-radius:6px; cursor:pointer; }
  .btn:hover { background:#203046; }
  #crumbs { font-size:13px; opacity:.9 }
  #crumbs a { color:#8ab4ff; text-decoration:none; }
  #search { min-width:260px; padding:7px 10px; border-radius:6px; border:1px solid #273446; background:#111823; color:#dfe7f1; }
  #topbar .spacer { flex:1; }

  /* main */
  #main { display:grid; grid-template-columns: 360px 1fr; height:100%; min-height:0; }
  #canvasWrap { position:relative; overflow:hidden; }
  #sun { width:100%; height:100%; display:block; background: radial-gradient(ellipse at center, #0e141c 0%, #0b0d10 60%); }
  #tooltip { position:fixed; pointer-events:none; background:#101826; border:1px solid #2b415c; border-radius:6px; padding:8px 10px; font-size:12px; display:none; z-index:10; }
  #panel { border-right:1px solid #1c2430; background:#0f141b; padding:12px; overflow:auto; display:flex; flex-direction:column; gap:12px; }
  #panel h3, #panel h4 { margin:0; }
  .kv { display:grid; grid-template-columns: 120px 1fr; gap:6px 10px; font-size:13px; }
  code { background:#15202b; padding:2px 4px; border-radius:4px; }
  ul.slim { margin:6px 0 0 18px; padding:0; }
  ul.slim li { margin:2px 0; }
  .panel-header { display:flex; flex-direction:column; gap:6px; }
  #saveStatus { font-size:12px; color:#8da3c1; }
  #info { flex:1; overflow:auto; display:flex; flex-direction:column; gap:12px; padding-right:6px; }
  .form-section { background:#111a28; border:1px solid #1f2a38; border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; }
  .form-section > h4 { margin:0; font-size:14px; }
  .form-field { display:flex; flex-direction:column; gap:6px; }
  .form-field label { font-size:11px; letter-spacing:.05em; text-transform:uppercase; opacity:.7; }
  .form-field input,
  .form-field textarea { width:100%; background:#0b121d; border:1px solid #243244; border-radius:6px; padding:6px 8px; color:#e7edf5; font:inherit; }
  .form-field textarea { resize:vertical; min-height:72px; }
  .list-items { display:flex; flex-direction:column; gap:8px; }
  .list-item { background:#0c141f; border:1px solid #1d2a3a; border-radius:6px; padding:8px; display:flex; flex-direction:column; gap:8px; }
  .list-item-header { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:13px; }
  .tag { padding:2px 6px; border-radius:999px; background:#1d2e44; color:#a4bedf; font-size:11px; letter-spacing:.05em; text-transform:uppercase; }
  .panel-actions { display:flex; gap:8px; flex-wrap:wrap; }
  .btn-secondary { border:1px solid #2a394c; background:#162031; color:#dfe7f1; padding:6px 10px; border-radius:6px; cursor:pointer; font:inherit; }
  .btn-secondary:hover { background:#1f2d44; }
  .danger-btn { color:#ff8787; border-color:#4a1f27; background:#2a0f15; }
  .danger-btn:hover { background:#3a151d; }
  .inline-actions { display:flex; gap:6px; }

  /* context menu */
  #ctx { position:fixed; display:none; z-index:20; background:#101826; border:1px solid #2b415c; border-radius:6px; overflow:hidden; min-width:220px; }
  #ctx button { display:block; width:100%; text-align:left; padding:8px 12px; background:none; border:none; color:#dfe7f1; cursor:pointer; font-size:13px; }
  #ctx button:hover { background:#203046; }

  footer { padding:8px 12px; border-top:1px solid #1c2430; background:#0f141b; font-size:12px; color:#98a6b8; }
</style>
</head>
<body>
  <div id="topbar">
    <button class="btn" id="homeBtn">Платформа</button>
    <div id="crumbs"></div>
    <div class="spacer"></div>
    <input id="search" placeholder="Поиск: сервис / модель / маршрут"/>
  </div>

  <div id="main">
    <aside id="panel">
      <div class="panel-header">
        <h3>Редактор данных</h3>
        <div id="saveStatus">Изменений нет</div>
      </div>
      <div id="info">Выберите элемент на диаграмме, чтобы редактировать связанные данные.</div>
      <div class="panel-actions">
        <button class="btn-secondary" id="importBtn">Загрузить файл…</button>
        <input type="file" id="dataFile" accept="application/json" hidden>
        <button class="btn-secondary" id="saveBtn" disabled>Сохранить в файл</button>
      </div>
    </aside>
    <div id="canvasWrap">
      <canvas id="sun"></canvas>
      <div id="tooltip"></div>
      <div id="ctx">
        <button data-act="open-swagger">Открыть Swagger</button>
        <button data-act="run-qa">Запустить QA</button>
        <button data-act="validate">Валидировать сервис</button>
        <button data-act="center">Сделать центром</button>
      </div>
    </div>
  </div>

  <footer>Sunburst map · drill-down · фильтры · поиск · контекстные действия</footer>

<script>
/* =================== utils =================== */
const $ = sel => document.querySelector(sel);
const deg = x => x * 180/Math.PI;
const rad = x => x * Math.PI/180;
function clamp(a,b,c){return Math.max(b,Math.min(c,a))}
function polar(cx, cy, r, th){ return [cx + r*Math.cos(th), cy + r*Math.sin(th)]; }
function arcPath(ctx, cx, cy, r0, r1, th0, th1){
  // draw annular sector
  ctx.beginPath();
  const [x0,y0] = polar(cx, cy, r0, th0);
  ctx.arc(cx, cy, r1, th0, th1, false);
  const [x1,y1] = polar(cx, cy, r0, th1);
  ctx.lineTo(x1,y1);
  ctx.arc(cx, cy, r0, th1, th0, true);
  ctx.closePath();
}
function lerp(a,b,t){ return a + (b-a)*t; }
const LABEL_FONT_FAMILY = "system-ui,Segoe UI,Roboto";
function makeLabel(ctx, name, geom){
  if(!geom) return null;
  const arc = geom.th1 - geom.th0;
  if(arc <= 0) return null;
  const rMid = (geom.r0 + geom.r1) / 2;
  const arcLength = Math.abs(arc) * rMid;
  const maxWidth = Math.max(0, arcLength - 10);
  if(maxWidth <= 0) return null;
  const prevFont = ctx.font;
  let result = null;
  const sizes = [12, 11, 10, 9, 8];
  for(const size of sizes){
    ctx.font = `${size}px ${LABEL_FONT_FAMILY}`;
    if(ctx.measureText(name).width <= maxWidth){
      result = { text: name, size };
      break;
    }
    let truncated = name;
    while(truncated.length > 1){
      truncated = truncated.slice(0, -1);
      const candidate = truncated + "…";
      if(ctx.measureText(candidate).width <= maxWidth){
        result = { text: candidate, size };
        break;
      }
    }
    if(result) break;
  }
  ctx.font = prevFont;
  return result;
}

const COLORS = {
  platform: "#1f6feb",
  service:  "#ffad60",
  backend:  "#4cc9f0",
  frontend: "#80ed99",
  qa:       "#c77dff",
  other:    "#91a7ff"
};
const CATEGORY_LABELS = { frontend: "Frontend", backend: "Backend", qa: "QA" };

let PLATFORM_DATA = null;
let UNSAVED_CHANGES = false;
let rebuildTimer = null;
const REBUILD_DEBOUNCE_MS = 600;

function deepClone(obj){
  return JSON.parse(JSON.stringify(obj));
}
function ensureArray(value){
  return Array.isArray(value) ? value.slice() : [];
}
function sanitizeStringArray(arr){
  return ensureArray(arr).map(item => String(item ?? ""));
}
function sanitizeMetrics(metrics){
  const result = {};
  if(metrics && typeof metrics === "object"){
    Object.entries(metrics).forEach(([key, value])=>{
      const k = String(key ?? "");
      if(!k) return;
      result[k] = String(value ?? "");
    });
  }
  return result;
}
function generateId(prefix){
  return `${prefix}-${Math.random().toString(36).slice(2,8)}`;
}
function sanitizeComponent(component = {}){
  const comp = { ...deepClone(component || {}) };
  comp.id = comp.id || generateId("cmp");
  comp.name = comp.name || "";
  comp.description = comp.description || "";
  comp.stack = comp.stack || "";
  comp.status = comp.status || "";
  comp.lead = comp.lead || "";
  comp.repo = comp.repo || "";
  comp.cadence = comp.cadence || "";
  comp.coverage = comp.coverage || "";
  comp.metrics = sanitizeMetrics(comp.metrics);
  if(comp.weight === undefined) comp.weight = 1;
  return comp;
}
function sanitizeComponentList(list){
  return ensureArray(list).map(item => sanitizeComponent(item));
}
function sanitizeService(service = {}){
  const src = { ...deepClone(service || {}) };
  src.id = src.id || generateId("service");
  src.name = src.name || "";
  src.summary = src.summary || "";
  src.mission = src.mission || "";
  src.owner = src.owner || "";
  src.lead = src.lead || "";
  src.status = src.status || "";
  src.impact = src.impact || "";
  src.sla = src.sla || "";
  src.roadmap = sanitizeStringArray(src.roadmap);
  src.frontend = sanitizeComponentList(src.frontend);
  src.backend = sanitizeComponentList(src.backend);
  src.qa = sanitizeComponentList(src.qa);
  src.categoryNotes = Object.assign({ frontend:"", backend:"", qa:"" }, src.categoryNotes || {});
  return src;
}
function sanitizePlatformData(raw = {}){
  const platform = deepClone(raw || {});
  platform.id = platform.id || "platform";
  const fallbackName = DEFAULT_PLATFORM_DATA.name || "Платформа";
  platform.name = platform.name || fallbackName;
  platform.description = platform.description || "";
  platform.principles = sanitizeStringArray(platform.principles);
  platform.services = ensureArray(platform.services).map(sanitizeService);
  return platform;
}
function getPlatform(){
  return PLATFORM_DATA || DEFAULT_PLATFORM_DATA;
}
function updateSaveStatus(){
  const status = $("#saveStatus");
  const btn = $("#saveBtn");
  if(status){
    status.textContent = UNSAVED_CHANGES ? "Есть несохранённые изменения" : "Изменений нет";
  }
  if(btn){
    btn.disabled = !UNSAVED_CHANGES;
  }
}
function markClean(){
  UNSAVED_CHANGES = false;
  updateSaveStatus();
  if(PLATFORM_DATA){
    savePlatformDataToLocal();
  }
}
function markDirty({ rebuild = true } = {}){
  UNSAVED_CHANGES = true;
  updateSaveStatus();
  if(PLATFORM_DATA){
    savePlatformDataToLocal();
  }
  if(rebuild) requestRebuild();
}
function requestRebuild(){
  if(rebuildTimer){
    clearTimeout(rebuildTimer);
  }
  rebuildTimer = setTimeout(()=>{
    rebuildTree().catch(()=>{});
  }, REBUILD_DEBOUNCE_MS);
}
function centerOn(id){
  CENTER_ID = id;
  rebuildTree().then(()=>openInfo(id));
}
function rerenderInfo(){
  openInfo(CENTER_ID);
}
const DEFAULT_PLATFORM_DATA = {
  id: "platform",
  name: "Платформа EGIDE",
  description: "Базовая платформа, объединяющая цифровые сервисы. Платформа — фундамент, остальные уровни наследуют от нее общий язык, стандарты и инфраструктуру.",
  principles: [
    "Единая платформа как точка сборки всех сервисов",
    "Принцип модели данных: все сервисы наследуют каноническую модель платформы",
    "Принцип REST-запросов: каждый сервис соблюдает платформенные контракты и идемпотентность",

    "Сервисы строятся поверх платформенных контрактов",
    "Frontend, Backend и QA для сервиса работают как единая автономная команда"
  ],
  services: [
    {
      id: "customer-onboarding",
      name: "Онбординг клиентов",
      summary: "Полный цикл привлечения и верификации клиента от заявки до активации продукта.",
      mission: "Сделать старт работы с продуктом прозрачным и полностью самообслуживаемым.",
      owner: "Stream Onboarding",
      lead: "Ирина Волкова",
      status: "production",
      impact: "Высокий",
      sla: "99.95%",
      roadmap: [
        "Автоматическая переоценка рисков",
        "Единая витрина тарифов",
        "Синхронизация статусов с партнёрами"
      ],
      categoryNotes: {
        frontend: "Команда UI обеспечивает быстрый отклик и доступность интерфейсов для разных устройств.",
        backend: "Микросервисы построены на событиях, обеспечивают непрерывность процессов KYC.",
        qa: "QA-группа держит контроль критических пользовательских сценариев и регресса."
      },
      frontend: [
        {
          id: "customer-portal",
          name: "Клиентский портал",
          description: "Главная точка входа для новых клиентов с трекингом статуса заявки.",
          stack: "React, Vite, RTK Query",
          status: "prod",
          lead: "Дмитрий Мизин",
          repo: "ssh://git/internal/customer-portal",
          metrics: { users: "42K MAU", uptime: "99.9%" }
        },
        {
          id: "kyc-form",
          name: "KYC форма",
          description: "Анкета с динамическими шагами, адаптирующимися под сегмент клиента.",
          stack: "React Hook Form, Zustand",
          status: "prod",
          lead: "Анна Савина",
          repo: "ssh://git/internal/kyc-form",
          metrics: { conversion: "+18% после A/B" }
        }
      ],
      backend: [
        {
          id: "workflow-engine",
          name: "Workflow Engine",
          description: "Оркестрация этапов онбординга, вебхуки и SLA мониторинг.",
          stack: "Kotlin, Spring Boot, Kafka",
          status: "prod",
          lead: "Павел Романов",
          repo: "ssh://git/internal/workflow-engine",
          metrics: { throughput: "12K процессов/ч", latency: "350 мс P95" }
        },
        {
          id: "risk-evaluator",
          name: "Risk Evaluator",
          description: "Скоринг рисков и проверка санкционных списков.",
          stack: "Python, FastAPI, Redis",
          status: "beta",
          lead: "Женя Гришин",
          repo: "ssh://git/internal/risk-evaluator",
          metrics: { coverage: "98% матчей" }
        }
      ],
      qa: [
        {
          id: "onboarding-regression",
          name: "Регрессия онбординга",
          description: "Полный регрессионный сценарий от заявки до активации.",
          stack: "Playwright, Allure",
          status: "nightly",
          lead: "Татьяна Журавлёва",
          cadence: "Каждые 4 часа",
          coverage: "85% критических путей"
        },
        {
          id: "api-contract-tests",
          name: "Контрактные тесты API",
          description: "Проверка соответствия API платформенным схемам.",
          stack: "Postman CLI, Newman",
          status: "ci",
          lead: "Михаил Осипов",
          cadence: "При каждом мерже",
          coverage: "100% публичных контрактов"
        }
      ]
    },
    {
      id: "payments-core",
      name: "Платёжное ядро",
      summary: "Приём и маршрутизация платежей во всех каналах.",
      mission: "Гарантировать мгновенную и безопасную обработку транзакций.",
      owner: "Payments Tribe",
      lead: "Максим Лавров",
      status: "production",
      impact: "Критический",
      sla: "99.99%",
      roadmap: [
        "Единый расчётный календарь",
        "Интеллектуальный ретраинг операций",
        "Realtime мониторинг отклонений"
      ],
      categoryNotes: {
        frontend: "Интерфейсы построены поверх платформенных компонентов и поддерживают white-label.",
        backend: "Домены платежей разделены на изолированные bounded context'ы.",
        qa: "Используется сет стейджингов и контрактные провайдеры для предотвращения регрессов."
      },
      frontend: [
        {
          id: "merchant-dashboard",
          name: "Кабинет мерчанта",
          description: "Отображение платежных потоков и управление витринами.",
          stack: "Vue 3, Pinia",
          status: "prod",
          lead: "Сергей Фомин",
          repo: "ssh://git/internal/merchant-dashboard",
          metrics: { nps: "54", sessions: "12K в сутки" }
        }
      ],
      backend: [
        {
          id: "payment-router",
          name: "Payment Router",
          description: "Маршрутизация операций по шлюзам и провайдерам.",
          stack: "Go, gRPC, Kafka",
          status: "prod",
          lead: "Влад Колесник",
          repo: "ssh://git/internal/payment-router",
          metrics: { latency: "180 мс P95", volume: "2.1M txn/день" }
        },
        {
          id: "settlement-service",
          name: "Settlement Service",
          description: "Расчёты и акты сверок с мерчантами.",
          stack: "Java, Quarkus, PostgreSQL",
          status: "prod",
          lead: "Екатерина Белова",
          repo: "ssh://git/internal/settlement-service",
          metrics: { reports: "6K отчётов/день" }
        }
      ],
      qa: [
        {
          id: "payment-e2e",
          name: "E2E платежи",
          description: "Сквозные сценарии приёма и возврата платежей.",
          stack: "Cypress, TypeScript",
          status: "prod",
          lead: "Юлия Горина",
          cadence: "Каждый час",
          coverage: "78% денежных потоков"
        },
        {
          id: "load-benchmarks",
          name: "Нагрузочные бенчмарки",
          description: "Профилирование производительности критических операций.",
          stack: "Gatling, Grafana",
          status: "weekly",
          lead: "Алексей Логинов",
          cadence: "Раз в неделю",
          coverage: "Пиковые сценарии чек-аута"
        }
      ]
    },
    {
      id: "insights-hub",
      name: "Insights Hub",
      summary: "Единое хранилище аналитики и витрин для продуктовых команд.",
      mission: "Доставлять аналитические инсайты в течение минут, а не дней.",
      owner: "Data Platform",
      lead: "Олег Сафронов",
      status: "beta",
      impact: "Стратегический",
      sla: "99.5%",
      roadmap: [
        "Self-service построение витрин",
        "ML-пайплайны с автоматическим деплоем",
        "Каталогирование показателей"
      ],
      categoryNotes: {
        frontend: "Витрины и конструкторы отчётов работают поверх design-system платформы.",
        backend: "Дата-канал построен на потоковой обработке и lakehouse-подходе.",
        qa: "QA команда поддерживает доверие к данным через автоматические проверки качества."
      },
      frontend: [
        {
          id: "analytics-workbench",
          name: "Analytics Workbench",
          description: "Конструктор отчётов и визуализаций для продуктовых менеджеров.",
          stack: "React, Recharts",
          status: "beta",
          lead: "Алина Рябова",
          repo: "ssh://git/internal/analytics-workbench",
          metrics: { adoption: "15 команд" }
        },
        {
          id: "metrics-catalog",
          name: "Каталог метрик",
          description: "Единое место для описаний KPI и метрик.",
          stack: "Next.js, Chakra UI",
          status: "beta",
          lead: "Никита Круглов",
          repo: "ssh://git/internal/metrics-catalog",
          metrics: { entries: "320 описаний" }
        }
      ],
      backend: [
        {
          id: "event-hub",
          name: "Event Hub",
          description: "Сбор и маршрутизация событий продукта.",
          stack: "Scala, Akka Streams, ClickHouse",
          status: "prod",
          lead: "Игорь Щербаков",
          repo: "ssh://git/internal/event-hub",
          metrics: { ingestion: "8 млрд событий/сутки" }
        },
        {
          id: "ml-pipeline",
          name: "ML Pipeline",
          description: "Платформа обучения и выката моделей.",
          stack: "Python, Airflow, MLflow",
          status: "beta",
          lead: "Лидия Бахметьева",
          repo: "ssh://git/internal/ml-pipeline",
          metrics: { models: "24 активных" }
        }
      ],
      qa: [
        {
          id: "data-quality",
          name: "Data Quality",
          description: "Автоматические проверки качества данных и алерты.",
          stack: "Great Expectations, DBT",
          status: "ci",
          lead: "Глеб Назаров",
          cadence: "При каждой поставке",
          coverage: "112 витрин"
        },
        {
          id: "schema-guardian",
          name: "Schema Guardian",
          description: "Контроль схем событий и обратная совместимость.",
          stack: "OpenAPI Diff, Kafka TestKit",
          status: "prod",
          lead: "Елена Афанасьева",
          cadence: "На каждый релиз",
          coverage: "58 контрактов"
        }
      ]
    }
  ]
};
// ---- NEW: animation & aggregation tuning ----
const MIN_ARC_DEG = 6;     // минимальный видимый угол сектора; меньше — уходит в "+N"
const ANIM_MS = 350;       // длительность анимации дрилл-дауна в мс
let PREV_GEOM = new Map(); // id -> {th0, th1, r0, r1} из прошлого кадра (для анимации)

function findServiceById(id){
  const platform = getPlatform();
  if(!platform || !platform.services) return null;
  return platform.services.find(s=>s.id===id);
}
function getCategoryItems(service, category){
  if(!service) return [];
  return (service[category] || []).slice();
}
function getEntity(id){
  if(!id) return getEntity("platform");
  if(id === "platform"){
    const platform = getPlatform();
    return { kind: "platform", id: "platform", title: platform ? platform.name : "Платформа" };
  }
  const parts = id.split(":");
  const service = findServiceById(parts[0]);
  if(!service){
    return null;
  }
  if(parts.length === 1){
    return { kind: "service", id: service.id, service, title: service.name };
  }
  const category = parts[1];
  if(!(category in CATEGORY_LABELS)){
    return null;
  }
  if(parts.length === 2){
    const items = getCategoryItems(service, category);
    return {
      kind: "category",
      id: `${service.id}:${category}`,
      service,
      category,
      items,
      title: `${CATEGORY_LABELS[category]} • ${service.name}`
    };
  }
  const componentId = parts.slice(2).join(":");
  const component = getCategoryItems(service, category).find(c=>c.id===componentId);
  if(!component){
    return null;
  }
  return {
    kind: "component",
    id: `${service.id}:${category}:${component.id}`,
    service,
    category,
    component,
    title: component.name
  };
}
function getCenterLabel(){
  const entity = getEntity(CENTER_ID);
  if(!entity) return CENTER_ID;
  if(entity.kind === "platform"){
    const platform = getPlatform();
    return platform ? platform.name : CENTER_ID;
  }
  if(entity.kind === "service") return entity.service.name;
  if(entity.kind === "category") return CATEGORY_LABELS[entity.category];
  if(entity.kind === "component") return entity.component.name;
  return CENTER_ID;
}
function computeBreadcrumbs(id){
  const entity = getEntity(id) || getEntity("platform");
  const platform = getPlatform();
  const crumbs = [{ id: "platform", label: platform ? platform.name : "Платформа" }];
  if(!entity || entity.kind === "platform"){
    return crumbs;
  }
  const service = entity.service || findServiceById(entity.id);
  if(service){
    crumbs.push({ id: service.id, label: service.name });
  }
  if((entity.kind === "category" || entity.kind === "component") && service){
    const catId = `${service.id}:${entity.category}`;
    crumbs.push({ id: catId, label: CATEGORY_LABELS[entity.category] });
  }
  if(entity.kind === "component" && entity.component){
    crumbs.push({ id: entity.id, label: entity.component.name });
  }
  return crumbs;
}
/* =================== state =================== */
let CANVAS, CTX, W, H, CX, CY, RING_W;
let FULL_GRAPH = null;     // {nodes, edges}
let TREE = null;           // root {id, name, type, weight, children[]}
let CENTER_ID = "platform";
let BREADCRUMBS = [];
let HOV = null;            // hovered node
let SELECTION = new Set(); // shift-select
let LAYOUT = [];           // list of drawn sectors with geometry for hit-test
let TOOLTIP = $("#tooltip");
let CTXMENU = $("#ctx");
let LAST_SEARCH = "";

/* =================== fetching =================== */
async function getJSON(url){
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error(r.statusText);
    return await r.json();
  }catch(e){ return null; }
}

async function loadGraph(){
  const g = await getJSON("/api/graph");
  if(g && g.nodes && g.edges) return g;
  // fallback demo
  return {
    nodes: [
      {id:"platform",label:"Platform",type:"platform"},
      {id:"auth",label:"Auth",type:"backend"},
      {id:"billing",label:"Billing",type:"backend"},
      {id:"ui",label:"WebApp",type:"frontend"},
      {id:"qa-core",label:"QA Core",type:"qa"},
      {id:"email",label:"Email",type:"backend"},
      {id:"reports",label:"Reports",type:"frontend"}
    ],
    edges: [
      {from:"auth",to:"platform",kind:"attached"},
      {from:"billing",to:"platform",kind:"attached"},
      {from:"ui",to:"platform",kind:"attached"},
      {from:"qa-core",to:"platform",kind:"attached"},
      {from:"email",to:"billing",kind:"depends_on"},
      {from:"reports",to:"billing",kind:"depends_on"},
      {from:"ui",to:"auth",kind:"depends_on"}
    ]
  };
}

const LOCAL_STORAGE_KEY = 'egide-platform-data';
function loadPlatformDataFromLocal(){
  try{
    const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
    if(raw){
      return sanitizePlatformData(JSON.parse(raw));
    }
  }catch(e){}
  return null;
}
function savePlatformDataToLocal(){
  try{
    if(PLATFORM_DATA){
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(PLATFORM_DATA));
    }
  }catch(e){}
}
async function fetchPlatformData(){
  try{
    const resp = await fetch('./data/platform-data.json', { cache: 'no-store' });
    if(resp.ok){
      const json = await resp.json();
      return sanitizePlatformData(json);
    }
  }catch(e){}
  return sanitizePlatformData(DEFAULT_PLATFORM_DATA);
}
async function loadPlatformData(){
  const local = loadPlatformDataFromLocal();
  if(local) return local;
  return await fetchPlatformData();
}
function downloadCurrentPlatformData(){
  if(!PLATFORM_DATA) return;
  const blob = new Blob([JSON.stringify(PLATFORM_DATA, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'platform-data.json';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
async function applyPlatformData(data, { clean = true } = {}){
  PLATFORM_DATA = sanitizePlatformData(data);
  CENTER_ID = 'platform';
  await rebuildTree();
  await openInfo('platform');
  if(clean){
    markClean();
  }else{
    updateSaveStatus();
    savePlatformDataToLocal();
  }
}

/* =================== tree building =================== */
function assignWeights(node){
  if(!node.children || node.children.length === 0){
    node.weight = node.weight || 1;
    return node.weight;
  }
  let sum = 0;
  node.children.forEach(child=>{
    sum += assignWeights(child);
  });
  node.weight = Math.max(1, sum);
  return node.weight;
}

async function buildTree(rootId){
  const platform = getPlatform();
  const entity = getEntity(rootId) || getEntity("platform");
  if(!entity || !platform){
    return assignWeights({ id: "platform", name: platform ? platform.name : "Платформа", type: "platform", weight: 1, children: [] });
  }

  if(entity.kind === "platform"){
    const services = ensureArray(platform.services);
    const root = {
      id: "platform",
      name: platform.name,
      type: "platform",
      weight: 1,
      children: services.map(service=>({
        id: service.id,
        name: service.name,
        type: "service",
        weight: Math.max(1, (ensureArray(service.frontend).length + ensureArray(service.backend).length + ensureArray(service.qa).length) || 1),
        children: []
      }))
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "service"){
    const service = entity.service;
    const children = [];
    ["frontend","backend","qa"].forEach(category=>{
      const items = getCategoryItems(service, category);
      if(items.length === 0) return;
      children.push({
        id: `${service.id}:${category}`,
        name: CATEGORY_LABELS[category],
        type: category,
        weight: Math.max(1, items.length),
        children: items.map(comp=>({
          id: `${service.id}:${category}:${comp.id}`,
          name: comp.name,
          type: category,
          weight: comp.weight || 1,
          children: []
        }))
      });
    });
    const root = {
      id: service.id,
      name: service.name,
      type: "service",
      weight: Math.max(1, children.length || 1),
      children
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "category"){
    const { service, category, items } = entity;
    const root = {
      id: `${service.id}:${category}`,
      name: `${CATEGORY_LABELS[category]}`,
      type: category,
      weight: Math.max(1, items.length || 1),
      children: items.map(comp=>({
        id: `${service.id}:${category}:${comp.id}`,
        name: comp.name,
        type: category,
        weight: comp.weight || 1,
        children: []
      }))
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "component"){
    const { service, category, component: comp } = entity;
    const root = {
      id: `${service.id}:${category}:${comp.id}`,
      name: comp.name,
      type: category,
      weight: 1,
      children: []
    };
    assignWeights(root);
    return root;
  }

  return assignWeights({ id: "platform", name: platform ? platform.name : "Платформа", type: "platform", weight: 1, children: [] });
}

/* =================== layout =================== */
function normalizeWeights(children){
  const s = children.reduce((a,c)=>a+(c.weight||1),0) || 1;
  children.forEach(c=> c._w = (c.weight||1)/s);
}
// ---- NEW: агрегируем слишком маленькие секторы в "+N" ----
function aggregateSmall(children, totalAngleRad){
  if (!children || children.length === 0) return children;
  const minAngle = rad(MIN_ARC_DEG);
  const result = [];
  const small = [];
  children.forEach(c=>{
    const frac = (c._w || 0);
    const span = totalAngleRad * frac;
    if (span < minAngle) small.push(c);
    else result.push(c);
  });
  if (small.length === 0) return result;
  // собираем "+N"
  const agg = {
    id: "__agg__" + small.map(s=>s.id).join("_").slice(0,40),
    name: `+${small.length}`,
    type: "other",
    weight: small.reduce((a,c)=> a + (c.weight||1), 0),
    children: small
  };
  agg._w = small.reduce((a,c)=> a + (c._w || 0), 0);
  result.push(agg);
  // нормализуем _w заново
  const sumW = result.reduce((a,c)=> a + (c._w || 0), 0) || 1;
  result.forEach(c=> c._w = (c._w || 0) / sumW);
  return result;
}

function layoutRadial(node, th0, th1, r0, ringW, out){
  node._geom = { th0, th1, r0, r1: r0 + ringW };
  out.push(node);

  if(!node.children || node.children.length===0) return;
  normalizeWeights(node.children);
  // агрегируем мелкие сектора перед рекурсией
  let kids = node.children.map(c=> ({...c}));
  const totalAngle = (th1 - th0);
  kids.forEach(c=> c._w = (c._w ?? (c.weight||1)));
  kids = aggregateSmall(kids, totalAngle);

  let cursor = th0;
  kids.forEach(ch=>{
    const span = totalAngle * ch._w;
    layoutRadial(ch, cursor, cursor+span, r0+ringW, ringW, out);
    cursor += span;
  });
}

/* =================== rendering =================== */
function resize(){
  const c = $("#sun");
  const rect = c.getBoundingClientRect();
  c.width = Math.floor(rect.width * devicePixelRatio);
  c.height = Math.floor(rect.height * devicePixelRatio);
  CANVAS = c; CTX = c.getContext("2d");
  W = c.width; H = c.height; CX = W/2; CY = H/2;
  RING_W = Math.min(W,H) * 0.12; // ширина одного кольца
}

function colorFor(type, selected){
  const base = COLORS[type] || COLORS.other;
  if(selected) return shade(base, 1.25);
  return base;
}
function shade(hex, k){
  const c = hex.replace('#','');
  const r = parseInt(c.slice(0,2),16), g = parseInt(c.slice(2,4),16), b = parseInt(c.slice(4,6),16);
  const rr = clamp(Math.round(r*k),0,255), gg=clamp(Math.round(g*k),0,255), bb=clamp(Math.round(b*k),0,255);
  return `#${rr.toString(16).padStart(2,'0')}${gg.toString(16).padStart(2,'0')}${bb.toString(16).padStart(2,'0')}`;
}

function draw(){
  CTX.clearRect(0,0,W,H);
  // background glow
  const g = CTX.createRadialGradient(CX,CY,0, CX,CY, Math.min(W,H)/2);
  g.addColorStop(0, "rgba(32,48,70,0.35)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  CTX.fillStyle = g;
  CTX.beginPath(); CTX.arc(CX,CY,Math.min(W,H)/2,0,Math.PI*2); CTX.fill();

  // center disk (Platform or current center)
  CTX.fillStyle = "#203b60";
  CTX.strokeStyle = "#3d6aa1";
  CTX.lineWidth = 2;
  CTX.beginPath(); CTX.arc(CX,CY, RING_W*0.65, 0, Math.PI*2); CTX.fill(); CTX.stroke();

  CTX.fillStyle = "#dfe7f1";
  CTX.font = `${Math.max(14, Math.floor(RING_W*0.22))}px ${LABEL_FONT_FAMILY}`;
  CTX.textAlign = "center";
  CTX.textBaseline = "middle";
  CTX.fillText(getCenterLabel(), CX, CY);

  // draw sectors
  LAYOUT = [];
  const flat = [];
  layoutRadial(TREE, -Math.PI/2, 1.5*Math.PI, RING_W*0.65, RING_W, flat);

  flat.forEach(n=>{
    if(n===TREE) return; // skip center geometry
    const sel = SELECTION.has(n.id);
    CTX.fillStyle = colorFor(n.type, sel);
    CTX.strokeStyle = "#2a3a50";
    CTX.lineWidth = 1;
    arcPath(CTX, CX, CY, n._geom.r0, n._geom.r1, n._geom.th0, n._geom.th1);
    CTX.fill(); CTX.stroke();

    // label (if arc large enough)
    const thMid = (n._geom.th0 + n._geom.th1)/2;
    const rMid = (n._geom.r0 + n._geom.r1)/2;
    const [lx,ly] = polar(CX,CY, rMid, thMid);
    const visibleAngle = deg(n._geom.th1 - n._geom.th0);
    if(visibleAngle > 8){
      const label = makeLabel(CTX, n.name, n._geom);
      if(label){
        CTX.save();
        CTX.translate(lx,ly);
        CTX.rotate(thMid + Math.PI/2);
        CTX.fillStyle = "#e7edf5";
        CTX.font = `${label.size}px ${LABEL_FONT_FAMILY}`;
        CTX.textAlign = "center"; CTX.textBaseline = "middle";
        CTX.fillText(label.text, 0, 0);
        CTX.restore();
      }
    }
    // keep for hit-test
    LAYOUT.push(n);
  });
}
async function drawAnimated(){
  // готовим новый плоский список (чтобы вычислить целевые геометрии)
  const targetFlat = [];
  layoutRadial(TREE, -Math.PI/2, 1.5*Math.PI, RING_W*0.65, RING_W, targetFlat);

  // сопоставим целевые геометрии по id
  const TARGET_MAP = new Map();
  targetFlat.forEach(n=>{
    if (n && n.id && n._geom) TARGET_MAP.set(n.id, n._geom);
  });

  const t0 = performance.now();
  const dur = ANIM_MS;

  return new Promise(res=>{
    const tick = (now)=>{
      const t = clamp((now - t0)/dur, 0, 1);
      // для кадра: интерполируем геометрию каждого узла между PREV_GEOM и TARGET_MAP
      LAYOUT = [];
      CTX.clearRect(0,0,W,H);
      // рисуем центр
      const g = CTX.createRadialGradient(CX,CY,0, CX,CY, Math.min(W,H)/2);
      g.addColorStop(0, "rgba(32,48,70,0.35)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      CTX.fillStyle = g;
      CTX.beginPath(); CTX.arc(CX,CY,Math.min(W,H)/2,0,Math.PI*2); CTX.fill();
      CTX.fillStyle = "#203b60";
      CTX.strokeStyle = "#3d6aa1";
      CTX.lineWidth = 2;
      CTX.beginPath(); CTX.arc(CX,CY, RING_W*0.65, 0, Math.PI*2); CTX.fill(); CTX.stroke();
      CTX.fillStyle = "#dfe7f1";
      CTX.font = `${Math.max(14, Math.floor(RING_W*0.22))}px ${LABEL_FONT_FAMILY}`;
      CTX.textAlign = "center"; CTX.textBaseline = "middle";
      CTX.fillText(getCenterLabel(), CX, CY);

      // интерполяция и рендер секторов
      targetFlat.forEach(n=>{
        if (n === TREE) return;
        const tgt = TARGET_MAP.get(n.id);
        const prev = PREV_GEOM.get(n.id) || tgt;
        const geom = {
          th0: lerp(prev.th0, tgt.th0, t),
          th1: lerp(prev.th1, tgt.th1, t),
          r0:  lerp(prev.r0,  tgt.r0,  t),
          r1:  lerp(prev.r1,  tgt.r1,  t),
        };
        // рисуем сектор
        const sel = SELECTION.has(n.id);
        CTX.fillStyle = colorFor(n.type, sel);
        CTX.strokeStyle = "#2a3a50";
        CTX.lineWidth = 1;
        arcPath(CTX, CX, CY, geom.r0, geom.r1, geom.th0, geom.th1);
        CTX.fill(); CTX.stroke();

        // подпись если видно
        const thMid = (geom.th0 + geom.th1)/2;
        const rMid = (geom.r0 + geom.r1)/2;
        const [lx,ly] = polar(CX,CY, rMid, thMid);
        const visibleAngle = deg(geom.th1 - geom.th0);
        if(visibleAngle > 8){
          const label = makeLabel(CTX, n.name, geom);
          if(label){
            CTX.save();
            CTX.translate(lx,ly);
            CTX.rotate(thMid + Math.PI/2);
            CTX.fillStyle = "#e7edf5";
            CTX.font = `${label.size}px ${LABEL_FONT_FAMILY}`;
            CTX.textAlign = "center"; CTX.textBaseline = "middle";
            CTX.fillText(label.text, 0, 0);
            CTX.restore();
          }
        }

        // сохраняем для hit-test текущую геометрию кадра
        const shadow = {...n, _geom: geom};
        LAYOUT.push(shadow);
      });

      if (t < 1) requestAnimationFrame(tick);
      else { draw(); res(); }
    };
    requestAnimationFrame(tick);
  });
}
/* =================== hit-testing =================== */
function hit(x,y){
  // convert to polar
  const dx = x*devicePixelRatio - CX, dy = y*devicePixelRatio - CY;
  const r = Math.hypot(dx,dy);
  let th = Math.atan2(dy,dx);
  while(th < -Math.PI/2) th += 2*Math.PI; // align with layout start
  while(th > 1.5*Math.PI) th -= 2*Math.PI;
  for(const n of LAYOUT){
    const g = n._geom;
    if(r >= g.r0 && r <= g.r1 && th >= g.th0 && th <= g.th1) return n;
  }
  return null;
}

/* =================== interactions =================== */
CANVAS = $("#sun");
CANVAS.addEventListener("mousemove", e=>{
  const n = hit(e.offsetX, e.offsetY);
  if(n !== HOV){
    HOV = n;
    if(n){
      TOOLTIP.style.display = "block";
      TOOLTIP.innerHTML = `<b>${n.name}</b><div style="opacity:.8;font-size:12px">${n.type} • вес: ${n.weight}</div>`;
    }else{
      TOOLTIP.style.display = "none";
    }
  }
  if(HOV){
    TOOLTIP.style.left = (e.clientX+12)+"px";
    TOOLTIP.style.top = (e.clientY+12)+"px";
  }
});
CANVAS.addEventListener("mouseleave", ()=>{
  HOV=null; TOOLTIP.style.display="none";
});
CANVAS.addEventListener("click", async e=>{
  CTXMENU.style.display="none";
  const n = hit(e.offsetX, e.offsetY);
  if(!n || (n.id && n.id.startsWith("__agg__"))) return;
  if(e.shiftKey){
    // multi-select toggle
    SELECTION.has(n.id) ? SELECTION.delete(n.id) : SELECTION.add(n.id);
    draw(); return;
  }
  // drill-down: make clicked sector the new center
  CENTER_ID = n.id;
  await rebuildTree();
  await openInfo(CENTER_ID);
});
CANVAS.addEventListener("contextmenu", e=>{
  e.preventDefault();
  const n = hit(e.offsetX, e.offsetY);
  if(!n || (n.id && n.id.startsWith("__agg__"))){ CTXMENU.style.display="none"; return; }
  CTXMENU.style.display = "block";
  CTXMENU.style.left = e.clientX+"px";
  CTXMENU.style.top = e.clientY+"px";
  CTXMENU.dataset.target = n.id;
});
document.addEventListener("click", e=>{
  if(!CTXMENU.contains(e.target)) CTXMENU.style.display = "none";
});
CTXMENU.addEventListener("click", async e=>{
  if(!(e.target instanceof HTMLElement)) return;
  const act = e.target.dataset.act;
  const id = CTXMENU.dataset.target;
  if(!act || !id) return;
  CTXMENU.style.display="none";
  if(act==="center"){ CENTER_ID = id; await rebuildTree(); await openInfo(CENTER_ID); }
  if(act==="open-swagger"){ window.open(`/docs`, "_blank"); }           // FastAPI Swagger
  if(act==="run-qa"){ alert(`QA для ${id} запущен (stub)`); }
  if(act==="validate"){ const r = await getJSON(`/api/validate`); alert(r? JSON.stringify(r).slice(0,500):"no response"); }
});

/* crumbs & controls */
$("#homeBtn").onclick = async ()=>{ CENTER_ID="platform"; await rebuildTree(); await openInfo("platform"); };
function escapeHtml(str){
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
function renderCrumbs(){
  const c = $("#crumbs");
  c.innerHTML = BREADCRUMBS.map((node,i)=>{
    const text = escapeHtml(node.label);
    const id = escapeHtml(node.id);
    return i<BREADCRUMBS.length-1 ? `<a href="#" data-i="${i}" data-id="${id}">${text}</a>` : `<b>${text}</b>`;
  }).join(" / ");
  c.querySelectorAll("a").forEach(a=>{
    a.onclick = async (ev)=>{
      ev.preventDefault();
      const i = +a.dataset.i;
      BREADCRUMBS = BREADCRUMBS.slice(0,i+1);
      CENTER_ID = BREADCRUMBS[BREADCRUMBS.length-1].id;
      await rebuildTree();
      await openInfo(CENTER_ID);
    };
  });
}

/* search */
$("#search").addEventListener("input", async (e)=>{
  LAST_SEARCH = e.target.value.trim().toLowerCase();
  draw(); // lightweight: highlight matches as selection
});

const saveBtn = $("#saveBtn");
const importBtn = $("#importBtn");
const dataFileInput = $("#dataFile");
if(saveBtn){
  saveBtn.addEventListener("click", ()=>{
    downloadCurrentPlatformData();
    markClean();
  });
}
if(importBtn && dataFileInput){
  importBtn.addEventListener("click", ()=>{
    dataFileInput.value = "";
    dataFileInput.click();
  });
  dataFileInput.addEventListener("change", async event=>{
    const file = event.target.files && event.target.files[0];
    if(!file) return;
    try{
      const text = await file.text();
      const parsed = JSON.parse(text);
      await applyPlatformData(parsed);
    }catch(err){
      alert("Не удалось загрузить данные из файла.");
    }
  });
}

/* selection highlight in draw() by name substring */
const _drawOrig = draw;
draw = function(){
  _drawOrig();
  if(!LAST_SEARCH) return;
  CTX.save();
  LAYOUT.forEach(n=>{
    if(n.name.toLowerCase().includes(LAST_SEARCH)){
      const g = n._geom;
      CTX.strokeStyle = "#ffd166";
      CTX.lineWidth = 3;
      arcPath(CTX, CX, CY, g.r0, g.r1, g.th0, g.th1);
      CTX.stroke();
    }
  });
  CTX.restore();
}

/* =================== info panel =================== */
function createButton(text, className, onClick){
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.textContent = text;
  btn.className = className;
  btn.addEventListener('click', onClick);
  return btn;
}
function createFormSection(title){
  const section = document.createElement('section');
  section.className = 'form-section';
  if(title){
    const heading = document.createElement('h4');
    heading.textContent = title;
    section.appendChild(heading);
  }
  return section;
}
function createInputField(label, value, options = {}){
  const { multiline = false, placeholder = '', type = 'text', rebuild = true, onInput, onAfterInput } = options;
  const wrapper = document.createElement('div');
  wrapper.className = 'form-field';
  const lab = document.createElement('label');
  lab.textContent = label;
  wrapper.appendChild(lab);
  const input = multiline ? document.createElement('textarea') : document.createElement('input');
  if(!multiline) input.type = type;
  input.value = value ?? '';
  if(placeholder) input.placeholder = placeholder;
  input.addEventListener('input', ev => {
    const val = ev.target.value;
    if(onInput) onInput(val);
    markDirty({ rebuild });
    if(onAfterInput) onAfterInput(val, input);
  });
  wrapper.appendChild(input);
  return { wrapper, input };
}
function createPlaceholder(text){
  const div = document.createElement('div');
  div.style.opacity = '.7';
  div.style.fontSize = '12px';
  div.textContent = text;
  return div;
}
function createStringListSection(title, list){
  const section = createFormSection(title);
  const items = document.createElement('div');
  items.className = 'list-items';
  if(!list.length){
    items.appendChild(createPlaceholder('Пока нет записей'));
  }
  list.forEach((value, index)=>{
    const item = document.createElement('div');
    item.className = 'list-item';
    const header = document.createElement('div');
    header.className = 'list-item-header';
    const titleEl = document.createElement('strong');
    titleEl.textContent = `Элемент ${index+1}`;
    header.appendChild(titleEl);
    const removeBtn = createButton('Удалить', 'btn-secondary danger-btn', ()=>{
      list.splice(index,1);
      markDirty({ rebuild: false });
      rerenderInfo();
    });
    header.appendChild(removeBtn);
    item.appendChild(header);
    const field = createInputField('Текст', value, {
      multiline:true,
      rebuild:false,
      onInput: val => { list[index] = val; }
    });
    item.appendChild(field.wrapper);
    items.appendChild(item);
  });
  section.appendChild(items);
  const addBtn = createButton('Добавить пункт', 'btn-secondary', ()=>{
    list.push('');
    markDirty({ rebuild: false });
    rerenderInfo();
  });
  section.appendChild(addBtn);
  return section;
}
function createMetricsField(component){
  if(!component.metrics || typeof component.metrics !== 'object'){
    component.metrics = {};
  }
  const metrics = component.metrics;
  const container = document.createElement('div');
  container.className = 'form-field';
  const label = document.createElement('label');
  label.textContent = 'Метрики';
  container.appendChild(label);
  const list = document.createElement('div');
  list.className = 'list-items';
  const entries = Object.entries(metrics);
  if(entries.length === 0){
    list.appendChild(createPlaceholder('Метрик пока нет'));
  }
  entries.forEach(([key,value], index)=>{
    let currentKey = key;
    const item = document.createElement('div');
    item.className = 'list-item';
    const header = document.createElement('div');
    header.className = 'list-item-header';
    const titleEl = document.createElement('strong');
    titleEl.textContent = currentKey || `Метрика ${index+1}`;
    header.appendChild(titleEl);
    const removeBtn = createButton('Удалить', 'btn-secondary danger-btn', ()=>{
      delete metrics[currentKey];
      markDirty({ rebuild:false });
      rerenderInfo();
    });
    header.appendChild(removeBtn);
    item.appendChild(header);
    const keyField = createInputField('Ключ', currentKey, {
      rebuild:false,
      onInput: newKey => {
        if(newKey === currentKey) return;
        const stored = metrics[currentKey];
        delete metrics[currentKey];
        currentKey = newKey;
        metrics[currentKey] = stored;
      },
      onAfterInput: newKey => {
        titleEl.textContent = newKey || `Метрика ${index+1}`;
      }
    });
    item.appendChild(keyField.wrapper);
    const valueField = createInputField('Значение', value, {
      rebuild:false,
      onInput: newValue => {
        metrics[currentKey] = newValue;
      }
    });
    item.appendChild(valueField.wrapper);
    list.appendChild(item);
  });
  container.appendChild(list);
  const addBtn = createButton('Добавить метрику', 'btn-secondary', ()=>{
    let baseKey = `metric-${Object.keys(metrics).length + 1}`;
    while(metrics[baseKey] !== undefined){
      baseKey = `metric-${Math.random().toString(36).slice(2,6)}`;
    }
    metrics[baseKey] = '';
    markDirty({ rebuild:false });
    rerenderInfo();
  });
  container.appendChild(addBtn);
  return container;
}
function createComponentListSection(service, category){
  if(!Array.isArray(service[category])){
    service[category] = [];
  }
  const items = service[category];
  const section = createFormSection(`${CATEGORY_LABELS[category]}`);
  const list = document.createElement('div');
  list.className = 'list-items';
  if(items.length === 0){
    list.appendChild(createPlaceholder('Компоненты ещё не добавлены'));
  }
  items.forEach((component, index)=>{
    const item = document.createElement('div');
    item.className = 'list-item';
    const header = document.createElement('div');
    header.className = 'list-item-header';
    const titleEl = document.createElement('strong');
    titleEl.textContent = component.name || `Элемент ${index+1}`;
    header.appendChild(titleEl);
    const actions = document.createElement('div');
    actions.className = 'inline-actions';
    actions.appendChild(createButton('Открыть', 'btn-secondary', ()=>{
      centerOn(`${service.id}:${category}:${component.id}`);
    }));
    actions.appendChild(createButton('Удалить', 'btn-secondary danger-btn', ()=>{
      const targetId = `${service.id}:${category}:${component.id}`;
      items.splice(index,1);
      markDirty();
      if(CENTER_ID === targetId){
        centerOn(service.id);
      }else{
        rerenderInfo();
        rebuildTree();
      }
    }));
    header.appendChild(actions);
    item.appendChild(header);
    item.appendChild(createInputField('Название', component.name, {
      rebuild:true,
      onInput: val => { component.name = val; },
      onAfterInput: val => { titleEl.textContent = val || `Элемент ${index+1}`; }
    }).wrapper);
    item.appendChild(createInputField('Описание', component.description, {
      multiline:true,
      rebuild:false,
      onInput: val => { component.description = val; }
    }).wrapper);
    item.appendChild(createInputField('Стек', component.stack, {
      rebuild:false,
      onInput: val => { component.stack = val; }
    }).wrapper);
    item.appendChild(createInputField('Статус', component.status, {
      rebuild:false,
      onInput: val => { component.status = val; }
    }).wrapper);
    item.appendChild(createInputField('Лид', component.lead, {
      rebuild:false,
      onInput: val => { component.lead = val; }
    }).wrapper);
    item.appendChild(createInputField('Репозиторий', component.repo, {
      rebuild:false,
      onInput: val => { component.repo = val; }
    }).wrapper);
    item.appendChild(createInputField('Частота', component.cadence, {
      rebuild:false,
      onInput: val => { component.cadence = val; }
    }).wrapper);
    item.appendChild(createInputField('Покрытие', component.coverage, {
      rebuild:false,
      onInput: val => { component.coverage = val; }
    }).wrapper);
    item.appendChild(createMetricsField(component));
    list.appendChild(item);
  });
  section.appendChild(list);
  section.appendChild(createButton(`Добавить ${CATEGORY_LABELS[category]}`, 'btn-secondary', ()=>{
    const newComponent = sanitizeComponent({ id: generateId(category) });
    items.push(newComponent);
    markDirty();
    rerenderInfo();
    rebuildTree();
  }));
  return section;
}
function renderPlatformEditor(container, platform){
  const general = createFormSection('Общие сведения');
  general.appendChild(createInputField('Название', platform.name, {
    rebuild:true,
    onInput: val => { platform.name = val; }
  }).wrapper);
  general.appendChild(createInputField('Описание', platform.description, {
    multiline:true,
    rebuild:false,
    onInput: val => { platform.description = val; }
  }).wrapper);
  container.appendChild(general);
  container.appendChild(createStringListSection('Принципы платформы', platform.principles));
  const servicesSection = createFormSection('Сервисы');
  const list = document.createElement('div');
  list.className = 'list-items';
  if(platform.services.length === 0){
    list.appendChild(createPlaceholder('Сервисы ещё не добавлены'));
  }
  platform.services.forEach((service, index)=>{
    const item = document.createElement('div');
    item.className = 'list-item';
    const header = document.createElement('div');
    header.className = 'list-item-header';
    const titleEl = document.createElement('strong');
    titleEl.textContent = service.name || `Сервис ${index+1}`;
    header.appendChild(titleEl);
    const actions = document.createElement('div');
    actions.className = 'inline-actions';
    actions.appendChild(createButton('Открыть', 'btn-secondary', ()=>{ centerOn(service.id); }));
    actions.appendChild(createButton('Удалить', 'btn-secondary danger-btn', ()=>{
      const platform = getPlatform();
      const idx = platform.services.findIndex(s=>s.id===service.id);
      if(idx >= 0){
        platform.services.splice(idx,1);
        markDirty();
        if(CENTER_ID === service.id || CENTER_ID.startsWith(`${service.id}:`)){
          centerOn('platform');
        }else{
          rerenderInfo();
          rebuildTree();
        }
      }
    }));
    header.appendChild(actions);
    item.appendChild(header);
    item.appendChild(createInputField('Название', service.name, {
      rebuild:true,
      onInput: val => { service.name = val; },
      onAfterInput: val => { titleEl.textContent = val || `Сервис ${index+1}`; }
    }).wrapper);
    item.appendChild(createInputField('Краткое описание', service.summary, {
      multiline:true,
      rebuild:false,
      onInput: val => { service.summary = val; }
    }).wrapper);
    list.appendChild(item);
  });
  servicesSection.appendChild(list);
  servicesSection.appendChild(createButton('Добавить сервис', 'btn-secondary', ()=>{
    const platform = getPlatform();
    const newService = sanitizeService({ name: 'Новый сервис', summary: '' });
    platform.services.push(newService);
    markDirty();
    centerOn(newService.id);
  }));
  container.appendChild(servicesSection);
}
function renderServiceEditor(container, service){
  const general = createFormSection('Общие сведения');
  general.appendChild(createInputField('Название', service.name, {
    rebuild:true,
    onInput: val => { service.name = val; }
  }).wrapper);
  general.appendChild(createInputField('Краткое описание', service.summary, {
    multiline:true,
    rebuild:false,
    onInput: val => { service.summary = val; }
  }).wrapper);
  general.appendChild(createInputField('Миссия', service.mission, {
    multiline:true,
    rebuild:false,
    onInput: val => { service.mission = val; }
  }).wrapper);
  general.appendChild(createInputField('Статус', service.status, {
    rebuild:false,
    onInput: val => { service.status = val; }
  }).wrapper);
  general.appendChild(createInputField('SLA', service.sla, {
    rebuild:false,
    onInput: val => { service.sla = val; }
  }).wrapper);
  general.appendChild(createInputField('Импакт', service.impact, {
    rebuild:false,
    onInput: val => { service.impact = val; }
  }).wrapper);
  general.appendChild(createInputField('Владелец', service.owner, {
    rebuild:false,
    onInput: val => { service.owner = val; }
  }).wrapper);
  general.appendChild(createInputField('Лид', service.lead, {
    rebuild:false,
    onInput: val => { service.lead = val; }
  }).wrapper);
  container.appendChild(general);
  container.appendChild(createStringListSection('Роадмап', service.roadmap));
  const notes = createFormSection('Заметки по направлениям');
  ['frontend','backend','qa'].forEach(cat => {
    notes.appendChild(createInputField(CATEGORY_LABELS[cat], service.categoryNotes[cat] || '', {
      multiline:true,
      rebuild:false,
      onInput: val => { service.categoryNotes[cat] = val; }
    }).wrapper);
  });
  container.appendChild(notes);
  ['frontend','backend','qa'].forEach(cat => {
    container.appendChild(createComponentListSection(service, cat));
  });
}
function renderCategoryEditor(container, entity){
  const { service, category } = entity;
  const note = createFormSection('Комментарий по направлению');
  note.appendChild(createInputField('Описание', service.categoryNotes[category] || '', {
    multiline:true,
    rebuild:false,
    onInput: val => { service.categoryNotes[category] = val; }
  }).wrapper);
  container.appendChild(note);
  container.appendChild(createComponentListSection(service, category));
}
function renderComponentEditor(container, entity){
  const { component } = entity;
  const general = createFormSection('Компонент');
  general.appendChild(createInputField('Название', component.name, {
    rebuild:true,
    onInput: val => { component.name = val; }
  }).wrapper);
  general.appendChild(createInputField('Описание', component.description, {
    multiline:true,
    rebuild:false,
    onInput: val => { component.description = val; }
  }).wrapper);
  general.appendChild(createInputField('Стек', component.stack, {
    rebuild:false,
    onInput: val => { component.stack = val; }
  }).wrapper);
  general.appendChild(createInputField('Статус', component.status, {
    rebuild:false,
    onInput: val => { component.status = val; }
  }).wrapper);
  general.appendChild(createInputField('Лид', component.lead, {
    rebuild:false,
    onInput: val => { component.lead = val; }
  }).wrapper);
  general.appendChild(createInputField('Репозиторий', component.repo, {
    rebuild:false,
    onInput: val => { component.repo = val; }
  }).wrapper);
  general.appendChild(createInputField('Частота', component.cadence, {
    rebuild:false,
    onInput: val => { component.cadence = val; }
  }).wrapper);
  general.appendChild(createInputField('Покрытие', component.coverage, {
    rebuild:false,
    onInput: val => { component.coverage = val; }
  }).wrapper);
  general.appendChild(createMetricsField(component));
  container.appendChild(general);
}
async function openInfo(id){
  const box = $("#info");
  if(!box) return;
  box.innerHTML = '';
  const entity = getEntity(id) || getEntity("platform");
  const platform = getPlatform();
  if(!entity || !platform){
    box.textContent = "Нет данных для выбранного элемента.";
    renderCrumbs(); draw();
    return;
  }

  if(entity.kind === "platform"){
    renderPlatformEditor(box, platform);
  }else if(entity.kind === "service"){
    renderServiceEditor(box, entity.service);
  }else if(entity.kind === "category"){
    renderCategoryEditor(box, entity);
  }else if(entity.kind === "component"){
    renderComponentEditor(box, entity);
  }else{
    box.textContent = "Нет данных для выбранного элемента.";
  }
  renderCrumbs(); draw();
}

/* =================== boot =================== */
async function rebuildTree(){
  // сохраняем прошлую геометрию для анимации
  PREV_GEOM.clear();
  LAYOUT.forEach(n=>{
    if (n && n.id && n._geom) PREV_GEOM.set(n.id, {...n._geom});
  });

  TREE = await buildTree(CENTER_ID);
  BREADCRUMBS = computeBreadcrumbs(CENTER_ID);
  renderCrumbs();
  resize();

  // рисуем с анимацией
  await drawAnimated();
}
window.addEventListener("resize", ()=>{ resize(); draw(); });

(async function init(){
  PLATFORM_DATA = await loadPlatformData();
  markClean();
  resize();
  FULL_GRAPH = await loadGraph();
  await rebuildTree();
  await openInfo("platform");
})();
</script>
</body>
</html>
