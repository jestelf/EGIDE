<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Платформа EGIDE — карта сервисов</title>
<style>
  :root { color-scheme: dark; }
  html,body { height:100%; }
  body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#0b0d10; color:#e7edf5; display:grid; grid-template-rows:auto 1fr auto; }

  /* top bar */
  #topbar { display:flex; align-items:center; gap:12px; padding:10px 14px; border-bottom:1px solid #1c2430; background:#0f141b; }
  .btn { border:1px solid #273446; background:#182333; color:#dfe7f1; padding:6px 10px; border-radius:6px; cursor:pointer; }
  .btn:hover { background:#203046; }
  #crumbs { font-size:13px; opacity:.9 }
  #crumbs a { color:#8ab4ff; text-decoration:none; }
  #search { min-width:260px; padding:7px 10px; border-radius:6px; border:1px solid #273446; background:#111823; color:#dfe7f1; }
  #topbar .spacer { flex:1; }

  /* main */
  #main { display:grid; grid-template-columns: 1fr 360px; height:100%; }
  #canvasWrap { position:relative; }
  #sun { width:100%; height:100%; display:block; background: radial-gradient(ellipse at center, #0e141c 0%, #0b0d10 60%); }
  #tooltip { position:fixed; pointer-events:none; background:#101826; border:1px solid #2b415c; border-radius:6px; padding:8px 10px; font-size:12px; display:none; z-index:10; }
  #panel { border-left:1px solid #1c2430; background:#0f141b; padding:12px; overflow:auto; }
  #panel h3, #panel h4 { margin:8px 0; }
  .kv { display:grid; grid-template-columns: 120px 1fr; gap:6px 10px; font-size:13px; }
  code { background:#15202b; padding:2px 4px; border-radius:4px; }
  ul.slim { margin:6px 0 0 18px; padding:0; }
  ul.slim li { margin:2px 0; }

  /* context menu */
  #ctx { position:fixed; display:none; z-index:20; background:#101826; border:1px solid #2b415c; border-radius:6px; overflow:hidden; min-width:220px; }
  #ctx button { display:block; width:100%; text-align:left; padding:8px 12px; background:none; border:none; color:#dfe7f1; cursor:pointer; font-size:13px; }
  #ctx button:hover { background:#203046; }

  footer { padding:8px 12px; border-top:1px solid #1c2430; background:#0f141b; font-size:12px; color:#98a6b8; }
</style>
</head>
<body>
  <div id="topbar">
    <button class="btn" id="homeBtn">Платформа</button>
    <div id="crumbs"></div>
    <div class="spacer"></div>
    <input id="search" placeholder="Поиск: сервис / модель / маршрут"/>
  </div>

  <div id="main">
    <div id="canvasWrap">
      <canvas id="sun"></canvas>
      <div id="tooltip"></div>
      <div id="ctx">
        <button data-act="open-swagger">Открыть Swagger</button>
        <button data-act="run-qa">Запустить QA</button>
        <button data-act="validate">Валидировать сервис</button>
        <button data-act="center">Сделать центром</button>
      </div>
    </div>
    <aside id="panel">
      <h3>Информация</h3>
      <div id="info">Клик по сектору — дрилл-даун. Shift+клик — мультивыделение. ПКМ — контекст-меню.</div>
    </aside>
  </div>

  <footer>Sunburst map · drill-down · фильтры · поиск · контекстные действия</footer>

<script>
/* =================== utils =================== */
const $ = sel => document.querySelector(sel);
const deg = x => x * 180/Math.PI;
const rad = x => x * Math.PI/180;
function clamp(a,b,c){return Math.max(b,Math.min(c,a))}
function polar(cx, cy, r, th){ return [cx + r*Math.cos(th), cy + r*Math.sin(th)]; }
function arcPath(ctx, cx, cy, r0, r1, th0, th1){
  // draw annular sector
  ctx.beginPath();
  const [x0,y0] = polar(cx, cy, r0, th0);
  ctx.arc(cx, cy, r1, th0, th1, false);
  const [x1,y1] = polar(cx, cy, r0, th1);
  ctx.lineTo(x1,y1);
  ctx.arc(cx, cy, r0, th1, th0, true);
  ctx.closePath();
}
function lerp(a,b,t){ return a + (b-a)*t; }
const LABEL_FONT_FAMILY = "system-ui,Segoe UI,Roboto";
function makeLabel(ctx, name, geom){
  if(!geom) return null;
  const arc = geom.th1 - geom.th0;
  if(arc <= 0) return null;
  const rMid = (geom.r0 + geom.r1) / 2;
  const arcLength = Math.abs(arc) * rMid;
  const maxWidth = Math.max(0, arcLength - 10);
  if(maxWidth <= 0) return null;
  const prevFont = ctx.font;
  let result = null;
  const sizes = [12, 11, 10, 9, 8];
  for(const size of sizes){
    ctx.font = `${size}px ${LABEL_FONT_FAMILY}`;
    if(ctx.measureText(name).width <= maxWidth){
      result = { text: name, size };
      break;
    }
    let truncated = name;
    while(truncated.length > 1){
      truncated = truncated.slice(0, -1);
      const candidate = truncated + "…";
      if(ctx.measureText(candidate).width <= maxWidth){
        result = { text: candidate, size };
        break;
      }
    }
    if(result) break;
  }
  ctx.font = prevFont;
  return result;
}

const COLORS = {
  platform: "#1f6feb",
  service:  "#ffad60",
  backend:  "#4cc9f0",
  frontend: "#80ed99",
  qa:       "#c77dff",
  other:    "#91a7ff"
};
const CATEGORY_LABELS = { frontend: "Frontend", backend: "Backend", qa: "QA" };
const DEMO_PLATFORM = {
  id: "platform",
  name: "Платформа EGIDE",
  description: "Базовая платформа, объединяющая цифровые сервисы. Платформа — фундамент, остальные уровни наследуют от нее общий язык, стандарты и инфраструктуру.",
  principles: [
    "Единая платформа как точка сборки всех сервисов",
    "Принцип модели данных: все сервисы наследуют каноническую модель платформы",
    "Принцип REST-запросов: каждый сервис соблюдает платформенные контракты и идемпотентность",
    "Сервисы строятся поверх платформенных контрактов",
    "Frontend, Backend и QA для сервиса работают как единая автономная команда"
  ],
  services: [
    {
      id: "customer-onboarding",
      name: "Онбординг клиентов",
      summary: "Полный цикл привлечения и верификации клиента от заявки до активации продукта.",
      mission: "Сделать старт работы с продуктом прозрачным и полностью самообслуживаемым.",
      owner: "Stream Onboarding",
      lead: "Ирина Волкова",
      status: "production",
      impact: "Высокий",
      sla: "99.95%",
      roadmap: [
        "Автоматическая переоценка рисков",
        "Единая витрина тарифов",
        "Синхронизация статусов с партнёрами"
      ],
      categoryNotes: {
        frontend: "Команда UI обеспечивает быстрый отклик и доступность интерфейсов для разных устройств.",
        backend: "Микросервисы построены на событиях, обеспечивают непрерывность процессов KYC.",
        qa: "QA-группа держит контроль критических пользовательских сценариев и регресса."
      },
      frontend: [
        {
          id: "customer-portal",
          name: "Клиентский портал",
          description: "Главная точка входа для новых клиентов с трекингом статуса заявки.",
          stack: "React, Vite, RTK Query",
          status: "prod",
          lead: "Дмитрий Мизин",
          repo: "ssh://git/internal/customer-portal",
          metrics: { users: "42K MAU", uptime: "99.9%" }
        },
        {
          id: "kyc-form",
          name: "KYC форма",
          description: "Анкета с динамическими шагами, адаптирующимися под сегмент клиента.",
          stack: "React Hook Form, Zustand",
          status: "prod",
          lead: "Анна Савина",
          repo: "ssh://git/internal/kyc-form",
          metrics: { conversion: "+18% после A/B" }
        }
      ],
      backend: [
        {
          id: "workflow-engine",
          name: "Workflow Engine",
          description: "Оркестрация этапов онбординга, вебхуки и SLA мониторинг.",
          stack: "Kotlin, Spring Boot, Kafka",
          status: "prod",
          lead: "Павел Романов",
          repo: "ssh://git/internal/workflow-engine",
          metrics: { throughput: "12K процессов/ч", latency: "350 мс P95" }
        },
        {
          id: "risk-evaluator",
          name: "Risk Evaluator",
          description: "Скоринг рисков и проверка санкционных списков.",
          stack: "Python, FastAPI, Redis",
          status: "beta",
          lead: "Женя Гришин",
          repo: "ssh://git/internal/risk-evaluator",
          metrics: { coverage: "98% матчей" }
        }
      ],
      qa: [
        {
          id: "onboarding-regression",
          name: "Регрессия онбординга",
          description: "Полный регрессионный сценарий от заявки до активации.",
          stack: "Playwright, Allure",
          status: "nightly",
          lead: "Татьяна Журавлёва",
          cadence: "Каждые 4 часа",
          coverage: "85% критических путей"
        },
        {
          id: "api-contract-tests",
          name: "Контрактные тесты API",
          description: "Проверка соответствия API платформенным схемам.",
          stack: "Postman CLI, Newman",
          status: "ci",
          lead: "Михаил Осипов",
          cadence: "При каждом мерже",
          coverage: "100% публичных контрактов"
        }
      ]
    },
    {
      id: "payments-core",
      name: "Платёжное ядро",
      summary: "Приём и маршрутизация платежей во всех каналах.",
      mission: "Гарантировать мгновенную и безопасную обработку транзакций.",
      owner: "Payments Tribe",
      lead: "Максим Лавров",
      status: "production",
      impact: "Критический",
      sla: "99.99%",
      roadmap: [
        "Единый расчётный календарь",
        "Интеллектуальный ретраинг операций",
        "Realtime мониторинг отклонений"
      ],
      categoryNotes: {
        frontend: "Интерфейсы построены поверх платформенных компонентов и поддерживают white-label.",
        backend: "Домены платежей разделены на изолированные bounded context'ы.",
        qa: "Используется сет стейджингов и контрактные провайдеры для предотвращения регрессов."
      },
      frontend: [
        {
          id: "merchant-dashboard",
          name: "Кабинет мерчанта",
          description: "Отображение платежных потоков и управление витринами.",
          stack: "Vue 3, Pinia",
          status: "prod",
          lead: "Сергей Фомин",
          repo: "ssh://git/internal/merchant-dashboard",
          metrics: { nps: "54", sessions: "12K в сутки" }
        }
      ],
      backend: [
        {
          id: "payment-router",
          name: "Payment Router",
          description: "Маршрутизация операций по шлюзам и провайдерам.",
          stack: "Go, gRPC, Kafka",
          status: "prod",
          lead: "Влад Колесник",
          repo: "ssh://git/internal/payment-router",
          metrics: { latency: "180 мс P95", volume: "2.1M txn/день" }
        },
        {
          id: "settlement-service",
          name: "Settlement Service",
          description: "Расчёты и акты сверок с мерчантами.",
          stack: "Java, Quarkus, PostgreSQL",
          status: "prod",
          lead: "Екатерина Белова",
          repo: "ssh://git/internal/settlement-service",
          metrics: { reports: "6K отчётов/день" }
        }
      ],
      qa: [
        {
          id: "payment-e2e",
          name: "E2E платежи",
          description: "Сквозные сценарии приёма и возврата платежей.",
          stack: "Cypress, TypeScript",
          status: "prod",
          lead: "Юлия Горина",
          cadence: "Каждый час",
          coverage: "78% денежных потоков"
        },
        {
          id: "load-benchmarks",
          name: "Нагрузочные бенчмарки",
          description: "Профилирование производительности критических операций.",
          stack: "Gatling, Grafana",
          status: "weekly",
          lead: "Алексей Логинов",
          cadence: "Раз в неделю",
          coverage: "Пиковые сценарии чек-аута"
        }
      ]
    },
    {
      id: "insights-hub",
      name: "Insights Hub",
      summary: "Единое хранилище аналитики и витрин для продуктовых команд.",
      mission: "Доставлять аналитические инсайты в течение минут, а не дней.",
      owner: "Data Platform",
      lead: "Олег Сафронов",
      status: "beta",
      impact: "Стратегический",
      sla: "99.5%",
      roadmap: [
        "Self-service построение витрин",
        "ML-пайплайны с автоматическим деплоем",
        "Каталогирование показателей"
      ],
      categoryNotes: {
        frontend: "Витрины и конструкторы отчётов работают поверх design-system платформы.",
        backend: "Дата-канал построен на потоковой обработке и lakehouse-подходе.",
        qa: "QA команда поддерживает доверие к данным через автоматические проверки качества."
      },
      frontend: [
        {
          id: "analytics-workbench",
          name: "Analytics Workbench",
          description: "Конструктор отчётов и визуализаций для продуктовых менеджеров.",
          stack: "React, Recharts",
          status: "beta",
          lead: "Алина Рябова",
          repo: "ssh://git/internal/analytics-workbench",
          metrics: { adoption: "15 команд" }
        },
        {
          id: "metrics-catalog",
          name: "Каталог метрик",
          description: "Единое место для описаний KPI и метрик.",
          stack: "Next.js, Chakra UI",
          status: "beta",
          lead: "Никита Круглов",
          repo: "ssh://git/internal/metrics-catalog",
          metrics: { entries: "320 описаний" }
        }
      ],
      backend: [
        {
          id: "event-hub",
          name: "Event Hub",
          description: "Сбор и маршрутизация событий продукта.",
          stack: "Scala, Akka Streams, ClickHouse",
          status: "prod",
          lead: "Игорь Щербаков",
          repo: "ssh://git/internal/event-hub",
          metrics: { ingestion: "8 млрд событий/сутки" }
        },
        {
          id: "ml-pipeline",
          name: "ML Pipeline",
          description: "Платформа обучения и выката моделей.",
          stack: "Python, Airflow, MLflow",
          status: "beta",
          lead: "Лидия Бахметьева",
          repo: "ssh://git/internal/ml-pipeline",
          metrics: { models: "24 активных" }
        }
      ],
      qa: [
        {
          id: "data-quality",
          name: "Data Quality",
          description: "Автоматические проверки качества данных и алерты.",
          stack: "Great Expectations, DBT",
          status: "ci",
          lead: "Глеб Назаров",
          cadence: "При каждой поставке",
          coverage: "112 витрин"
        },
        {
          id: "schema-guardian",
          name: "Schema Guardian",
          description: "Контроль схем событий и обратная совместимость.",
          stack: "OpenAPI Diff, Kafka TestKit",
          status: "prod",
          lead: "Елена Афанасьева",
          cadence: "На каждый релиз",
          coverage: "58 контрактов"
        }
      ]
    }
  ]
};
// ---- NEW: animation & aggregation tuning ----
const MIN_ARC_DEG = 6;     // минимальный видимый угол сектора; меньше — уходит в "+N"
const ANIM_MS = 350;       // длительность анимации дрилл-дауна в мс
let PREV_GEOM = new Map(); // id -> {th0, th1, r0, r1} из прошлого кадра (для анимации)

function findServiceById(id){
  return DEMO_PLATFORM.services.find(s=>s.id===id);
}
function getCategoryItems(service, category){
  if(!service) return [];
  return (service[category] || []).slice();
}
function getEntity(id){
  if(!id) return getEntity("platform");
  if(id === "platform"){
    return { kind: "platform", id: "platform", title: DEMO_PLATFORM.name };
  }
  const parts = id.split(":");
  const service = findServiceById(parts[0]);
  if(!service){
    return null;
  }
  if(parts.length === 1){
    return { kind: "service", id: service.id, service, title: service.name };
  }
  const category = parts[1];
  if(!(category in CATEGORY_LABELS)){
    return null;
  }
  if(parts.length === 2){
    const items = getCategoryItems(service, category);
    return {
      kind: "category",
      id: `${service.id}:${category}`,
      service,
      category,
      items,
      title: `${CATEGORY_LABELS[category]} • ${service.name}`
    };
  }
  const componentId = parts.slice(2).join(":");
  const component = getCategoryItems(service, category).find(c=>c.id===componentId);
  if(!component){
    return null;
  }
  return {
    kind: "component",
    id: `${service.id}:${category}:${component.id}`,
    service,
    category,
    component,
    title: component.name
  };
}
function getCenterLabel(){
  const entity = getEntity(CENTER_ID);
  if(!entity) return CENTER_ID;
  if(entity.kind === "platform") return DEMO_PLATFORM.name;
  if(entity.kind === "service") return entity.service.name;
  if(entity.kind === "category") return CATEGORY_LABELS[entity.category];
  if(entity.kind === "component") return entity.component.name;
  return CENTER_ID;
}
function computeBreadcrumbs(id){
  const entity = getEntity(id) || getEntity("platform");
  const crumbs = [{ id: "platform", label: DEMO_PLATFORM.name }];
  if(!entity || entity.kind === "platform"){
    return crumbs;
  }
  const service = entity.service || findServiceById(entity.id);
  if(service){
    crumbs.push({ id: service.id, label: service.name });
  }
  if((entity.kind === "category" || entity.kind === "component") && service){
    const catId = `${service.id}:${entity.category}`;
    crumbs.push({ id: catId, label: CATEGORY_LABELS[entity.category] });
  }
  if(entity.kind === "component" && entity.component){
    crumbs.push({ id: entity.id, label: entity.component.name });
  }
  return crumbs;
}
/* =================== state =================== */
let CANVAS, CTX, W, H, CX, CY, RING_W;
let FULL_GRAPH = null;     // {nodes, edges}
let TREE = null;           // root {id, name, type, weight, children[]}
let CENTER_ID = "platform";
let BREADCRUMBS = [{id:"platform", label: DEMO_PLATFORM.name }];
let HOV = null;            // hovered node
let SELECTION = new Set(); // shift-select
let LAYOUT = [];           // list of drawn sectors with geometry for hit-test
let TOOLTIP = $("#tooltip");
let CTXMENU = $("#ctx");
let LAST_SEARCH = "";

/* =================== fetching =================== */
async function getJSON(url){
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error(r.statusText);
    return await r.json();
  }catch(e){ return null; }
}

async function loadGraph(){
  const g = await getJSON("/api/graph");
  if(g && g.nodes && g.edges) return g;
  // fallback demo
  return {
    nodes: [
      {id:"platform",label:"Platform",type:"platform"},
      {id:"auth",label:"Auth",type:"backend"},
      {id:"billing",label:"Billing",type:"backend"},
      {id:"ui",label:"WebApp",type:"frontend"},
      {id:"qa-core",label:"QA Core",type:"qa"},
      {id:"email",label:"Email",type:"backend"},
      {id:"reports",label:"Reports",type:"frontend"}
    ],
    edges: [
      {from:"auth",to:"platform",kind:"attached"},
      {from:"billing",to:"platform",kind:"attached"},
      {from:"ui",to:"platform",kind:"attached"},
      {from:"qa-core",to:"platform",kind:"attached"},
      {from:"email",to:"billing",kind:"depends_on"},
      {from:"reports",to:"billing",kind:"depends_on"},
      {from:"ui",to:"auth",kind:"depends_on"}
    ]
  };
}

/* =================== tree building =================== */
function assignWeights(node){
  if(!node.children || node.children.length === 0){
    node.weight = node.weight || 1;
    return node.weight;
  }
  let sum = 0;
  node.children.forEach(child=>{
    sum += assignWeights(child);
  });
  node.weight = Math.max(1, sum);
  return node.weight;
}

async function buildTree(rootId){
  const entity = getEntity(rootId) || getEntity("platform");
  if(!entity){
    return assignWeights({ id: "platform", name: DEMO_PLATFORM.name, type: "platform", weight: 1, children: [] });
  }

  if(entity.kind === "platform"){
    const root = {
      id: "platform",
      name: DEMO_PLATFORM.name,
      type: "platform",
      weight: 1,
      children: DEMO_PLATFORM.services.map(service=>({
        id: service.id,
        name: service.name,
        type: "service",
        weight: Math.max(1, (service.frontend.length + service.backend.length + service.qa.length) || 1),
        children: []
      }))
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "service"){
    const service = entity.service;
    const children = [];
    ["frontend","backend","qa"].forEach(category=>{
      const items = getCategoryItems(service, category);
      if(items.length === 0) return;
      children.push({
        id: `${service.id}:${category}`,
        name: CATEGORY_LABELS[category],
        type: category,
        weight: Math.max(1, items.length),
        children: items.map(comp=>({
          id: `${service.id}:${category}:${comp.id}`,
          name: comp.name,
          type: category,
          weight: comp.weight || 1,
          children: []
        }))
      });
    });
    const root = {
      id: service.id,
      name: service.name,
      type: "service",
      weight: Math.max(1, children.length || 1),
      children
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "category"){
    const service = entity.service;
    const category = entity.category;
    const items = entity.items;
    const root = {
      id: `${service.id}:${category}`,
      name: `${CATEGORY_LABELS[category]}`,
      type: category,
      weight: Math.max(1, items.length || 1),
      children: items.map(comp=>({
        id: `${service.id}:${category}:${comp.id}`,
        name: comp.name,
        type: category,
        weight: comp.weight || 1,
        children: []
      }))
    };
    assignWeights(root);
    return root;
  }

  if(entity.kind === "component"){
    const service = entity.service;
    const category = entity.category;
    const comp = entity.component;
    const root = {
      id: `${service.id}:${category}:${comp.id}`,
      name: comp.name,
      type: category,
      weight: 1,
      children: []
    };
    assignWeights(root);
    return root;
  }

  return assignWeights({ id: "platform", name: DEMO_PLATFORM.name, type: "platform", weight: 1, children: [] });
}

/* =================== layout =================== */
function normalizeWeights(children){
  const s = children.reduce((a,c)=>a+(c.weight||1),0) || 1;
  children.forEach(c=> c._w = (c.weight||1)/s);
}
// ---- NEW: агрегируем слишком маленькие секторы в "+N" ----
function aggregateSmall(children, totalAngleRad){
  if (!children || children.length === 0) return children;
  const minAngle = rad(MIN_ARC_DEG);
  const result = [];
  const small = [];
  children.forEach(c=>{
    const frac = (c._w || 0);
    const span = totalAngleRad * frac;
    if (span < minAngle) small.push(c);
    else result.push(c);
  });
  if (small.length === 0) return result;
  // собираем "+N"
  const agg = {
    id: "__agg__" + small.map(s=>s.id).join("_").slice(0,40),
    name: `+${small.length}`,
    type: "other",
    weight: small.reduce((a,c)=> a + (c.weight||1), 0),
    children: small
  };
  agg._w = small.reduce((a,c)=> a + (c._w || 0), 0);
  result.push(agg);
  // нормализуем _w заново
  const sumW = result.reduce((a,c)=> a + (c._w || 0), 0) || 1;
  result.forEach(c=> c._w = (c._w || 0) / sumW);
  return result;
}

function layoutRadial(node, th0, th1, r0, ringW, out){
  node._geom = { th0, th1, r0, r1: r0 + ringW };
  out.push(node);

  if(!node.children || node.children.length===0) return;
  normalizeWeights(node.children);
  // агрегируем мелкие сектора перед рекурсией
  let kids = node.children.map(c=> ({...c}));
  const totalAngle = (th1 - th0);
  kids.forEach(c=> c._w = (c._w ?? (c.weight||1)));
  kids = aggregateSmall(kids, totalAngle);

  let cursor = th0;
  kids.forEach(ch=>{
    const span = totalAngle * ch._w;
    layoutRadial(ch, cursor, cursor+span, r0+ringW, ringW, out);
    cursor += span;
  });
}

/* =================== rendering =================== */
function resize(){
  const c = $("#sun");
  const rect = c.getBoundingClientRect();
  c.width = Math.floor(rect.width * devicePixelRatio);
  c.height = Math.floor(rect.height * devicePixelRatio);
  CANVAS = c; CTX = c.getContext("2d");
  W = c.width; H = c.height; CX = W/2; CY = H/2;
  RING_W = Math.min(W,H) * 0.12; // ширина одного кольца
}

function colorFor(type, selected){
  const base = COLORS[type] || COLORS.other;
  if(selected) return shade(base, 1.25);
  return base;
}
function shade(hex, k){
  const c = hex.replace('#','');
  const r = parseInt(c.slice(0,2),16), g = parseInt(c.slice(2,4),16), b = parseInt(c.slice(4,6),16);
  const rr = clamp(Math.round(r*k),0,255), gg=clamp(Math.round(g*k),0,255), bb=clamp(Math.round(b*k),0,255);
  return `#${rr.toString(16).padStart(2,'0')}${gg.toString(16).padStart(2,'0')}${bb.toString(16).padStart(2,'0')}`;
}

function draw(){
  CTX.clearRect(0,0,W,H);
  // background glow
  const g = CTX.createRadialGradient(CX,CY,0, CX,CY, Math.min(W,H)/2);
  g.addColorStop(0, "rgba(32,48,70,0.35)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  CTX.fillStyle = g;
  CTX.beginPath(); CTX.arc(CX,CY,Math.min(W,H)/2,0,Math.PI*2); CTX.fill();

  // center disk (Platform or current center)
  CTX.fillStyle = "#203b60";
  CTX.strokeStyle = "#3d6aa1";
  CTX.lineWidth = 2;
  CTX.beginPath(); CTX.arc(CX,CY, RING_W*0.65, 0, Math.PI*2); CTX.fill(); CTX.stroke();

  CTX.fillStyle = "#dfe7f1";
  CTX.font = `${Math.max(14, Math.floor(RING_W*0.22))}px ${LABEL_FONT_FAMILY}`;
  CTX.textAlign = "center";
  CTX.textBaseline = "middle";
  CTX.fillText(getCenterLabel(), CX, CY);

  // draw sectors
  LAYOUT = [];
  const flat = [];
  layoutRadial(TREE, -Math.PI/2, 1.5*Math.PI, RING_W*0.65, RING_W, flat);

  flat.forEach(n=>{
    if(n===TREE) return; // skip center geometry
    const sel = SELECTION.has(n.id);
    CTX.fillStyle = colorFor(n.type, sel);
    CTX.strokeStyle = "#2a3a50";
    CTX.lineWidth = 1;
    arcPath(CTX, CX, CY, n._geom.r0, n._geom.r1, n._geom.th0, n._geom.th1);
    CTX.fill(); CTX.stroke();

    // label (if arc large enough)
    const thMid = (n._geom.th0 + n._geom.th1)/2;
    const rMid = (n._geom.r0 + n._geom.r1)/2;
    const [lx,ly] = polar(CX,CY, rMid, thMid);
    const visibleAngle = deg(n._geom.th1 - n._geom.th0);
    if(visibleAngle > 8){
      const label = makeLabel(CTX, n.name, n._geom);
      if(label){
        CTX.save();
        CTX.translate(lx,ly);
        CTX.rotate(thMid + Math.PI/2);
        CTX.fillStyle = "#e7edf5";
        CTX.font = `${label.size}px ${LABEL_FONT_FAMILY}`;
        CTX.textAlign = "center"; CTX.textBaseline = "middle";
        CTX.fillText(label.text, 0, 0);
        CTX.restore();
      }
    }
    // keep for hit-test
    LAYOUT.push(n);
  });
}
async function drawAnimated(){
  // готовим новый плоский список (чтобы вычислить целевые геометрии)
  const targetFlat = [];
  layoutRadial(TREE, -Math.PI/2, 1.5*Math.PI, RING_W*0.65, RING_W, targetFlat);

  // сопоставим целевые геометрии по id
  const TARGET_MAP = new Map();
  targetFlat.forEach(n=>{
    if (n && n.id && n._geom) TARGET_MAP.set(n.id, n._geom);
  });

  const t0 = performance.now();
  const dur = ANIM_MS;

  return new Promise(res=>{
    const tick = (now)=>{
      const t = clamp((now - t0)/dur, 0, 1);
      // для кадра: интерполируем геометрию каждого узла между PREV_GEOM и TARGET_MAP
      LAYOUT = [];
      CTX.clearRect(0,0,W,H);
      // рисуем центр
      const g = CTX.createRadialGradient(CX,CY,0, CX,CY, Math.min(W,H)/2);
      g.addColorStop(0, "rgba(32,48,70,0.35)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      CTX.fillStyle = g;
      CTX.beginPath(); CTX.arc(CX,CY,Math.min(W,H)/2,0,Math.PI*2); CTX.fill();
      CTX.fillStyle = "#203b60";
      CTX.strokeStyle = "#3d6aa1";
      CTX.lineWidth = 2;
      CTX.beginPath(); CTX.arc(CX,CY, RING_W*0.65, 0, Math.PI*2); CTX.fill(); CTX.stroke();
      CTX.fillStyle = "#dfe7f1";
      CTX.font = `${Math.max(14, Math.floor(RING_W*0.22))}px ${LABEL_FONT_FAMILY}`;
      CTX.textAlign = "center"; CTX.textBaseline = "middle";
      CTX.fillText(getCenterLabel(), CX, CY);

      // интерполяция и рендер секторов
      targetFlat.forEach(n=>{
        if (n === TREE) return;
        const tgt = TARGET_MAP.get(n.id);
        const prev = PREV_GEOM.get(n.id) || tgt;
        const geom = {
          th0: lerp(prev.th0, tgt.th0, t),
          th1: lerp(prev.th1, tgt.th1, t),
          r0:  lerp(prev.r0,  tgt.r0,  t),
          r1:  lerp(prev.r1,  tgt.r1,  t),
        };
        // рисуем сектор
        const sel = SELECTION.has(n.id);
        CTX.fillStyle = colorFor(n.type, sel);
        CTX.strokeStyle = "#2a3a50";
        CTX.lineWidth = 1;
        arcPath(CTX, CX, CY, geom.r0, geom.r1, geom.th0, geom.th1);
        CTX.fill(); CTX.stroke();

        // подпись если видно
        const thMid = (geom.th0 + geom.th1)/2;
        const rMid = (geom.r0 + geom.r1)/2;
        const [lx,ly] = polar(CX,CY, rMid, thMid);
        const visibleAngle = deg(geom.th1 - geom.th0);
        if(visibleAngle > 8){
          const label = makeLabel(CTX, n.name, geom);
          if(label){
            CTX.save();
            CTX.translate(lx,ly);
            CTX.rotate(thMid + Math.PI/2);
            CTX.fillStyle = "#e7edf5";
            CTX.font = `${label.size}px ${LABEL_FONT_FAMILY}`;
            CTX.textAlign = "center"; CTX.textBaseline = "middle";
            CTX.fillText(label.text, 0, 0);
            CTX.restore();
          }
        }

        // сохраняем для hit-test текущую геометрию кадра
        const shadow = {...n, _geom: geom};
        LAYOUT.push(shadow);
      });

      if (t < 1) requestAnimationFrame(tick);
      else { draw(); res(); }
    };
    requestAnimationFrame(tick);
  });
}
/* =================== hit-testing =================== */
function hit(x,y){
  // convert to polar
  const dx = x*devicePixelRatio - CX, dy = y*devicePixelRatio - CY;
  const r = Math.hypot(dx,dy);
  let th = Math.atan2(dy,dx);
  while(th < -Math.PI/2) th += 2*Math.PI; // align with layout start
  while(th > 1.5*Math.PI) th -= 2*Math.PI;
  for(const n of LAYOUT){
    const g = n._geom;
    if(r >= g.r0 && r <= g.r1 && th >= g.th0 && th <= g.th1) return n;
  }
  return null;
}

/* =================== interactions =================== */
CANVAS = $("#sun");
CANVAS.addEventListener("mousemove", e=>{
  const n = hit(e.offsetX, e.offsetY);
  if(n !== HOV){
    HOV = n;
    if(n){
      TOOLTIP.style.display = "block";
      TOOLTIP.innerHTML = `<b>${n.name}</b><div style="opacity:.8;font-size:12px">${n.type} • вес: ${n.weight}</div>`;
    }else{
      TOOLTIP.style.display = "none";
    }
  }
  if(HOV){
    TOOLTIP.style.left = (e.clientX+12)+"px";
    TOOLTIP.style.top = (e.clientY+12)+"px";
  }
});
CANVAS.addEventListener("mouseleave", ()=>{
  HOV=null; TOOLTIP.style.display="none";
});
CANVAS.addEventListener("click", async e=>{
  CTXMENU.style.display="none";
  const n = hit(e.offsetX, e.offsetY);
  if(!n || (n.id && n.id.startsWith("__agg__"))) return;
  if(e.shiftKey){
    // multi-select toggle
    SELECTION.has(n.id) ? SELECTION.delete(n.id) : SELECTION.add(n.id);
    draw(); return;
  }
  // drill-down: make clicked sector the new center
  CENTER_ID = n.id;
  await rebuildTree();
  await openInfo(CENTER_ID);
});
CANVAS.addEventListener("contextmenu", e=>{
  e.preventDefault();
  const n = hit(e.offsetX, e.offsetY);
  if(!n || (n.id && n.id.startsWith("__agg__"))){ CTXMENU.style.display="none"; return; }
  CTXMENU.style.display = "block";
  CTXMENU.style.left = e.clientX+"px";
  CTXMENU.style.top = e.clientY+"px";
  CTXMENU.dataset.target = n.id;
});
document.addEventListener("click", e=>{
  if(!CTXMENU.contains(e.target)) CTXMENU.style.display = "none";
});
CTXMENU.addEventListener("click", async e=>{
  if(!(e.target instanceof HTMLElement)) return;
  const act = e.target.dataset.act;
  const id = CTXMENU.dataset.target;
  if(!act || !id) return;
  CTXMENU.style.display="none";
  if(act==="center"){ CENTER_ID = id; await rebuildTree(); await openInfo(CENTER_ID); }
  if(act==="open-swagger"){ window.open(`/docs`, "_blank"); }           // FastAPI Swagger
  if(act==="run-qa"){ alert(`QA для ${id} запущен (stub)`); }
  if(act==="validate"){ const r = await getJSON(`/api/validate`); alert(r? JSON.stringify(r).slice(0,500):"no response"); }
});

/* crumbs & controls */
$("#homeBtn").onclick = async ()=>{ CENTER_ID="platform"; await rebuildTree(); await openInfo("platform"); };
function escapeHtml(str){
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
function renderCrumbs(){
  const c = $("#crumbs");
  c.innerHTML = BREADCRUMBS.map((node,i)=>{
    const text = escapeHtml(node.label);
    const id = escapeHtml(node.id);
    return i<BREADCRUMBS.length-1 ? `<a href="#" data-i="${i}" data-id="${id}">${text}</a>` : `<b>${text}</b>`;
  }).join(" / ");
  c.querySelectorAll("a").forEach(a=>{
    a.onclick = async (ev)=>{
      ev.preventDefault();
      const i = +a.dataset.i;
      BREADCRUMBS = BREADCRUMBS.slice(0,i+1);
      CENTER_ID = BREADCRUMBS[BREADCRUMBS.length-1].id;
      await rebuildTree();
      await openInfo(CENTER_ID);
    };
  });
}

/* search */
$("#search").addEventListener("input", async (e)=>{
  LAST_SEARCH = e.target.value.trim().toLowerCase();
  draw(); // lightweight: highlight matches as selection
});

/* selection highlight in draw() by name substring */
const _drawOrig = draw;
draw = function(){
  _drawOrig();
  if(!LAST_SEARCH) return;
  CTX.save();
  LAYOUT.forEach(n=>{
    if(n.name.toLowerCase().includes(LAST_SEARCH)){
      const g = n._geom;
      CTX.strokeStyle = "#ffd166";
      CTX.lineWidth = 3;
      arcPath(CTX, CX, CY, g.r0, g.r1, g.th0, g.th1);
      CTX.stroke();
    }
  });
  CTX.restore();
}

/* =================== info panel =================== */
async function openInfo(id){
  const box = $("#info");
  const entity = getEntity(id) || getEntity("platform");
  if(!entity){
    box.textContent = "Нет данных для выбранного элемента.";
    renderCrumbs(); draw();
    return;
  }

  if(entity.kind === "platform"){
    const principles = DEMO_PLATFORM.principles.map(p=>`<li>${escapeHtml(p)}</li>`).join("");
    const services = DEMO_PLATFORM.services.map(s=>`<li><b>${escapeHtml(s.name)}</b> — ${escapeHtml(s.summary)}</li>`).join("");
    box.innerHTML = `
      <h4>${escapeHtml(DEMO_PLATFORM.name)}</h4>
      <p style="margin:4px 0 10px">${escapeHtml(DEMO_PLATFORM.description)}</p>
      <div class="kv" style="margin-bottom:10px">
        <div>Принципы:</div>
        <div><ul class="slim">${principles}</ul></div>
      </div>
      <h4 style="margin-top:6px">Сервисы на платформе</h4>
      <ul class="slim">${services}</ul>
    `;
    renderCrumbs(); draw();
    return;
  }

  if(entity.kind === "service"){
    const service = entity.service;
    const categories = ["frontend","backend","qa"].map(cat=>{
      const items = getCategoryItems(service, cat);
      if(items.length === 0) return "";
      const names = items.map(c=>escapeHtml(c.name)).join(", ");
      return `<li><b>${CATEGORY_LABELS[cat]}</b> (${items.length}) — ${names}</li>`;
    }).filter(Boolean).join("");
    const roadmap = (service.roadmap||[]).map(item=>`<li>${escapeHtml(item)}</li>`).join("");
    box.innerHTML = `
      <h4>${escapeHtml(service.name)}</h4>
      <p style="margin:4px 0 10px">${escapeHtml(service.summary)}</p>
      <div class="kv">
        <div>Миссия:</div><div>${escapeHtml(service.mission)}</div>
        <div>Статус:</div><div>${escapeHtml(service.status || "—")}</div>
        <div>SLA:</div><div>${escapeHtml(service.sla || "—")}</div>
        <div>Импакт:</div><div>${escapeHtml(service.impact || "—")}</div>
        <div>Владелец:</div><div>${escapeHtml(service.owner || "—")}</div>
        <div>Лид:</div><div>${escapeHtml(service.lead || "—")}</div>
      </div>
      <h4 style="margin-top:12px">Команды сервиса</h4>
      <ul class="slim">${categories || "<li>Нет артефактов</li>"}</ul>
      <h4 style="margin-top:12px">Фокус роадмапа</h4>
      <ul class="slim">${roadmap || "<li>—</li>"}</ul>
    `;
    renderCrumbs(); draw();
    return;
  }

  if(entity.kind === "category"){
    const { service, category, items } = entity;
    const note = (service.categoryNotes && service.categoryNotes[category]) ? escapeHtml(service.categoryNotes[category]) : "";
    const rows = items.map(comp=>{
      const metaParts = [];
      if(comp.stack) metaParts.push(`<span>Стек: ${escapeHtml(comp.stack)}</span>`);
      if(comp.status) metaParts.push(`<span>Статус: ${escapeHtml(comp.status)}</span>`);
      if(comp.lead) metaParts.push(`<span>Лид: ${escapeHtml(comp.lead)}</span>`);
      if(comp.repo) metaParts.push(`<span>Репозиторий: <code>${escapeHtml(comp.repo)}</code></span>`);
      if(comp.cadence) metaParts.push(`<span>Частота: ${escapeHtml(comp.cadence)}</span>`);
      if(comp.coverage) metaParts.push(`<span>Покрытие: ${escapeHtml(comp.coverage)}</span>`);
      if(comp.metrics){
        Object.entries(comp.metrics).forEach(([k,v])=>{
          metaParts.push(`<span>${escapeHtml(k)}: ${escapeHtml(v)}</span>`);
        });
      }
      const meta = metaParts.length ? `<div style="display:flex;flex-direction:column;gap:2px;margin-top:4px;opacity:.85">${metaParts.join("")}</div>` : "";
      return `<li><b>${escapeHtml(comp.name)}</b><div style="opacity:.8">${escapeHtml(comp.description || "Без описания")}</div>${meta}</li>`;
    }).join("");
    box.innerHTML = `
      <h4>${escapeHtml(CATEGORY_LABELS[category])} · ${escapeHtml(service.name)}</h4>
      <p style="margin:4px 0 10px">${note}</p>
      <ul class="slim">${rows || "<li>Нет элементов</li>"}</ul>
    `;
    renderCrumbs(); draw();
    return;
  }

  if(entity.kind === "component"){
    const { service, category, component } = entity;
    const metrics = component.metrics ? Object.entries(component.metrics).map(([k,v])=>`<li><span>${escapeHtml(k)}:</span> <b>${escapeHtml(v)}</b></li>`).join("") : "";
    box.innerHTML = `
      <h4>${escapeHtml(component.name)}</h4>
      <p style="margin:4px 0 10px">${escapeHtml(component.description || "")}</p>
      <div class="kv">
        <div>Сервис:</div><div>${escapeHtml(service.name)}</div>
        <div>Направление:</div><div>${escapeHtml(CATEGORY_LABELS[category])}</div>
        <div>Стек:</div><div>${escapeHtml(component.stack || "—")}</div>
        <div>Статус:</div><div>${escapeHtml(component.status || "—")}</div>
        <div>Лид:</div><div>${escapeHtml(component.lead || "—")}</div>
        <div>Репозиторий:</div><div>${component.repo ? `<code>${escapeHtml(component.repo)}</code>` : "—"}</div>
        <div>Частота:</div><div>${escapeHtml(component.cadence || "—")}</div>
        <div>Покрытие:</div><div>${escapeHtml(component.coverage || "—")}</div>
      </div>
      ${metrics ? `<h4 style="margin-top:12px">Метрики</h4><ul class="slim">${metrics}</ul>` : ""}
    `;
    renderCrumbs(); draw();
    return;
  }
}

/* =================== boot =================== */
async function rebuildTree(){
  // сохраняем прошлую геометрию для анимации
  PREV_GEOM.clear();
  LAYOUT.forEach(n=>{
    if (n && n.id && n._geom) PREV_GEOM.set(n.id, {...n._geom});
  });

  TREE = await buildTree(CENTER_ID);
  BREADCRUMBS = computeBreadcrumbs(CENTER_ID);
  renderCrumbs();
  resize();

  // рисуем с анимацией
  await drawAnimated();
}
window.addEventListener("resize", ()=>{ resize(); draw(); });

(async function init(){
  resize();
  FULL_GRAPH = await loadGraph();
  await rebuildTree();
  await openInfo("platform");
})();
</script>
</body>
</html>
